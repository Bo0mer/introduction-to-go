Функции и масиви
27.10.2021

* Но преди това...


* Въпрос за точка #1

Какво трябва да направим за да може даден идентификатор да се достъпва извън
пакета, в който е дефиниран?

* Въпрос за точка #1

Какво трябва да направим за да може даден идентификатор да се достъпва извън
пакета, в който е дефиниран.

- Да ползваме главна буква. 

* Въпрос за точка #2

Какъв тип или стойност имат следните променливи?

    a := 42
    var x string
    var z = 3.14
    var p *int

* Въпрос за точка #3

Какъв е резултатът от изпълнението на следната програма?

    package main

    func main() {
        var x, y, z int
        z = z + x
        println(z)
    }

* Въпрос за точка #4

Какъв е идиоматичния начин за правене на enum в Go?

За какво се използва `iota` в Go и коя подред буква в гръцката азбука е?

* Въпрос за точка #4

Какъв е идиоматичния начин за правене на enum в Go?

За какво се използва `iota` в Go и коя подред буква в гръцката азбука е?

- `iota`

    const (
        City = iota
        Town
        Village
    )

* Funcs 101

- Функциите са основна структурна единица в Go
- Всеки проблем, който някога ще решавате, ще е разбит на функции
- Една функция върши точно едно нещо
- ... в противен случай правите нещо грешно
- Може да връща няколко резултата
- Последните три точки не си противоречат взаимно
- DRY
- Редът, в който са дефинирани, не е от значение
- Може и да изпада в паника (буквално)


* С ключовата дума func могат да се създават три неща

1. Функции

2. Ламбди

3. Методи


* Функции

.play code/funcs_and_pointers/simple_funcs.go

* Аргументи

    func foo(a int, b string) float64

Функцията foo приема int и string и връща float64

- Винаги работим върху копия от аргументите
- Ако това не ни устройва, подаваме указател
- Нямаме стойности по подразбиране (optional parameters) или overloading

Когато няколко аргумента са от един тип:

    func bar(a, b int, c float64) float64

* Произволен брой аргументи

    func sum(args ...int) int

Функцията sum приема произволен брой числа и връща техния сбор

.code code/funcs_and_pointers/lots_of_arguments.go /^func sum/,/^}/

Извикваме я с колкото ни трябват

    sum()           //0
    sum(2, 3)       //5
    sum(2, 3, 4, 5) //14

Трябва да е последния аргумент на функцията
* ще говорим по-подробно за `range`

* Множество стойности като резултат

.play code/funcs_and_pointers/many_results.go

* Защо?

- Няма нуждата от някои грозни C идиоми, като ...
- ... модифициране на аргумент, подаден по адрес
- ... errno
- По-лесно справяне с грешки


* Как е реализирано в "стари" езици:

- C/C++ и компания: масив или структура
- Python: tuple-и

* Как е реализирано в Go?
- Много просто: връщате каквото ви трябва

* Ами ако не ни трябват всичките резултати?

1. Знаем, че ако дефинираме променлива и не я използваме, гърми
2. Ако искаме онзи сбор и не ни интересува броят аргументи, това ще изгърми

    result, count := sumAndCount(2, 3, 4, 5)

3. Ако нямаме нужда от дадена стойност, я присвояваме на _:

    result, _ := sumAndCount(2, 3, 4, 5)

- Тя не се запазва и не можем да я достъпим след това
- По-полезно е, отколкото ви се струва


* Именовани резултати

.code code/funcs_and_pointers/named_sum_and_count.go /^func sum/,/^}/

- Резултатите се инициализират преди изпълнението на функцията
- Добра идея са, ако пишем често в тях по време на изпълнение
- Няма нужда да ги указваме при return

* Фунцкиите като стойности

- В реда на нещата е функция да приема функция

.code code/funcs_and_pointers/as_values.go /^func foo/,/^}/

- Няма нищо лошо в това и да връщаме функция

.code code/funcs_and_pointers/as_values.go /^func createRandomGenerator/,/^}/

- Въобще, можем да ги присвояваме на стойност
- Но можем да ги сравняваме само с `nil`

* ...или да изпълни себе си
.play code/funcs_and_pointers/factorial.go /^func factorial/,/^}/


* Именоване на функции

- Кратки, описателни имена
- Започва с буква, последвана от букви, цифри или _
- Помните ли, че тук всеки стринг е UTF-8?
- `ЗнаетеЛиЧеHelloWorldНаКитайскиЕ世界` е валидно име на функция
- *НЕ* пишете такива имена!
- camelCase
- camelCase, не snake_case
- Ако функцията ни трябва извън текущия пакет: CamelCase


* Анонимни функции

  func(x, y int) int { return x * y }

- НЕ можем да дефинираме нормална функция в тялото на друга.
- Но пък можем да създаваме ламбди
- Ламбдите си нямат име... очевидно
- Удобни са за дребни неща

.play code/funcs_and_pointers/lambdas.go /^func main/,/^}/

* Scope, visibility & escape analysis

.play code/funcs_and_pointers/visibility.go

Променливата `count` нужна ли е въобще?

* defer

- `defer` е специален механизъм на езика
- `defer` добавя *извикване* на функция в един списък (стек)
- Когато обграждащата функция приключи, тези извиквания се изпълняват в обратен ред

.play code/funcs_and_pointers/defer_example_0.go /^func main/,/^}/

* Пример:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }

        written, err = io.Copy(dst, src)
        dst.Close()
        src.Close()
        return
    }

Какви са проблемите с този код?


* По-красивият, правилен и работещ начин е това:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }
        defer src.Close()

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }
        defer dst.Close()

        return io.Copy(dst, src)
    }

`defer` се използва за сигурно и лесно почистване на ресурси (отворени файлове, заключени `mutex-и`, etc.)

* Доуточнения

- `defer` statement-ите ни позволяват да мислим за затварянето на файловете веднага след отварянето им
- Това ни гарантира, че няма да забравим в никой случай за затварянето им, независимо кой, кога и как променя кода след нас

* Три прости правила за defer (1)

- Аргументите на `defer` се оценяват, когато самият `defer` statement се оценява

    func a() {
        i := 0
        defer fmt.Println(i)
        i++
        return
    }

- Това принтира "0"

* Три прости правила за defer (2)

- Функциите се изпълняват в `LIFO` ред

    func b() {
        for i := 0; i < 4; i++ {
            defer fmt.Print(i)
        }
    }

- Това изписва "3210"

* Три прости правила за defer (3)

- `defer` -натите функции могат да "пипат" по именованите връщани аргументи на обграждащата функция

    func c() (i int) {
        defer func() { i++ }()
        return 1
    }

- Тази функция връща "2"
- Това е удобно, за да променяме връщаните стойности от функции, примерно за да върнем грешка

* Примери

.play code/funcs_and_pointers/defer_example1.go /^func deferExample/,/^}/

-

.play code/funcs_and_pointers/defer_example2.go /^func deferExample/,/^}/

* Методи

За тях ще си говорим като стигнем до дефиниране на типове

* Структури от данни

* Arrays

- По нашенски: масиви
- Последователност от еднакви по тип елементи
- С конкретна фиксирана дължина

.play code/data_structures/array.go /^func main()/,/^}/

Очевидно броим от 0


* Инициализация

    var x [5]string
    x[0] = "Баба"
    x[1] = "меца"
    x[2] = "яде"
    x[3] = "от"
    x[4] = "медеца"

или накратко:

    x := [6]float64{98, 93, 77, 82, 83}

Чакай малко! Подали сме само 5 числа.

    x[5] == 0


* Компилаторите могат да броят!

- ??!?

    x := [...]string{"Incredible", "isn't", "it?"}

- В този случай `x` е от тип `[3]string`

* Сравняване на масиви

Да разгледаме следния код

.play code/data_structures/array_comparison.go /dqdo/,/fmt/


* Големината на масив е част от типа му

.play code/data_structures/array_comparison_error.go /dqdo/,/fmt/


* Черва на масивите

- Те са стойности, копират се, а не се предават по референция

    func (foo [100]uint32)

- Дори, когато правим

    a := [100]float64
    b := a

- Може да се избегне с указател към масив

    func (foo *[100]uint32)

- Няма нужда да го ползвате, ще видите защо другия път

* Полезнотии

- `len()` - връща размера като int
- `range` - ключова дума, която позволява да итерираме по индекс и стойност

    for index, value := range arr {
        ...
    }



    for index := 0; index < len(arr); index++ {
        value := arr[index]
        ...
    }

Тези два цикъла са еквивалентни

_(Заради_range_нямаме_нужда_от_foreach)_

* Това е много готино, но...

- Не могат да растат
- Или да се свиват
- Спомняте ли указателя към масив? А ако искаме да подадем масив с друга дължина?
- Какво е това!? Живеем в 2021, не може ли да се направи нещо?


* Slices

За тях следващия път.

* Следващия път

- Slice-ове, map-ове
- Типове и интерфейси
