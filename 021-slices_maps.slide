Slices, maps & custom types
10.11.2021

* Slices

От предния път. Какъв ще е резултатът от изпълнението на следната програма?

.play code/data_structures/array_comparison_error.go /dqdo/,/fmt/

* Slices

От предния път. Как може да променим големината на масив?

* Напомняне да се пусне запис

* Slices

Като масивите имат дължина и могат да се индексират, но дължината им може да се променя*.

    var x []float64

Горното само създава променливата, а се инициализира по следния начин:

    x := make([]float64, 5)

Това указва на слайса да бъде с размер 5. Всеки слайс е част от масив с не по-малка дължина от слайса.

    x := make([]float64, 5, 10)

Това е същото като горното, но този слайс сочи към масив с размер 10.


* Без изрично `make(...)`

    numbers := []float64{0, 1.2, 3.4, 55.3}

- Създава slice-a "numbers" от тип []float64 и го запълва


* Слайсове в действие

    arr := [6]float64{1, 2, 3, 4, 5, 6}
    x := arr[1:5]

Създаваме слайс от втори до пети елемент включително на масива arr.

    x := arr[2:] // Взема всички без първите два елемента
    x := arr[:2] // Взема първите два елемента
    x := arr[:]  // Взема всички елементи


* Не точно масиви

- Външно се държат като такива
- Но всъщност един slice е (малка) структура, която е построена "върху" array
- Всички операции с тях са евтини
- Всяко оразмеряване прави _нов_ евтин слайс
- ... който "сочи" към същия масив в паметта


* Структура

.image assets/slice.jpg

    x := []int{2, 3, 5, 7, 11}

Създава нов slice, който сочи към нов масив от 5 елемента.

    y := x[1:3]

Създава нов slice, но не и нов масив - използва се вече съществуващия за x.

* Полезнотии


* len и cap

- `len(x)` - Взема размера на slice-а
- `cap(x)` - Взема размера на масива, към който slice-а сочи

.play code/data_structures/len_vs_cap.go /^func main()/,/^}/

* Нулева стойност

- Както всичко в Go си имат нулева стойност и това е nil

    var foo []uint32
    foo == nil // True

- `len` и `cap` връщат 0 за нулев slice

    len(foo) == cap(foo) == 0

* Резултатни slice-ове

- Ако разгледаме

    x := []uint32{0, 1, 2, 3, 4, 5, 6, 7}
    y := x[:]
    y[4] = 42
    x[4] == 42  // True

- `y` не копира съдържанието на `x`
- Kоето прави операцията много ефективна, независимо колко е голям `x`
- Подаването като аргумент на функция копира самия slice, но не стойностите на масива, към който сочи
- Създава се нов slice, който сочи към масива на оригинала

* `cap` - втори епизод

    x := []uint32{0, 1, 2, 3, 4, 5, 6, 7}
    y := x[2:4]  // [2, 3]
    y = y[:cap(y)]  // [2, 3, 4, 5, 6, 7]

- Опит да го увеличим над оригиналната големина на масива води до runtime panic

* append

Built-in функция, която добавя елементи към края на slice:

    sliceA := []int{1, 2, 3}
    sliceB := append(sliceA, 4, 5) // [1 2 3 4 5]

Може да добавя и един slice към друг:

    sliceC := append(sliceA, sliceB...)

Ако в резултатния slice има достатъчно място, той се използва непроменен. Ако няма, автоматично се заделя по-голям slice:

    sliceD := make([]int, 0, 3)   // len = 0, cap = 3
    sliceD = append(sliceD, 1, 2) // len = 2, cap = 3
    sliceD = append(sliceD, 2, 4) // len = 4, cap = 6

* Трик с append

Изтриване на n-ия елемент от слайс

	x := []int{1, 2, 3, 4, 5}
	x = append(x[:n], x[n+1:]...)

Ако n = 2:

	[]int{1, 2, 4, 5}


* copy(dst, src)

- Копира елементи от един слайс в друг
- Връща броя копирани елементи
- Source и destination може да се припокриват

* copy(dst, src) - примери

    var l int
    slice1 := []int{1, 2, 3, 4}
    slice2 := []int{7, 6, 5}

Копираме трите елемента от `slice2` в `slice1`

    l = copy(slice1, slice2) // slice1 = [7 6 5 4], l = 3

Копираме края на slice1 в началото му

    l = copy(slice1, slice1[2:]) // slice1 = [3 4 3 4], l = 2

Копираме slice1 в slice2

    l = copy(slice2, slice1) // slice2 = [1 2 3], l = 3
    // Копират се само първите 3 елемента, защото len(slice2) = 3


* slice "gotchas"

1. Опит за писане в неинициализиран слайс води до паника.

2. Масивите, в които се съхраняват данните на слайсовете, не се чистят от garbage collector-a, докато има референции (слайсове) към тях.

    // WARNING: shitty code, don't do this at home. We are professionals!
    func GetFileHeader(filename string) []byte {
        b, _ := ioutil.ReadFile(filename)
        return b[:10]
    }

Цялото съдържание на файла няма да бъде изчистено от паметта, докато първите 10 байта се ползват някъде.

Решение: copy() в нов слайс

* Maps

Неподредена колекция от двойки ключове и стойности

    var x map[string]int // Ключовете в x са низове, а стойностите числа


За да го инициализраме, ползваме `make`:

    x := make(map[string]int)

Подобно на слайсовете, писането в неинициализиран map води до паника.

Ползваме го почти както масиви и слайсове. Добавяне на стойност:

    x["key"] = 10

За да вземем стойност по ключ:

    value, ok := x["key"]

`ok` е `true`, ако съществува двойка с такъв ключ. В противен случай, `value` е нулевата стойност на типа (`""` за `string`) и `ok` е false.


* Полезнотии

- Бързо инициализиране:

    wordcount := map[string]int{"word1": 10, "word2": 5}

- Изтриването на стойност става с `delete`:

    x := make(map[string]int)
    delete(x, "key") // Изтрива двойката с ключ е "key". Ако няма такава, нищо не се случва.

- Проверка дали даден ключ съществува:

    if _, ok := x["key"]; ok {
        fmt.Println("key exists")
    }

- Начален размер:

    y := make(map[string]int, 10)

* Итериране

- Итерирането става с `range`:

    for key, value := range m {
        fmt.Println("Key:", key, "Value:", value)
    }

- Не знаем в какъв ред ще бъдат обходени елементите. Не трябва и да ни
  интересува.
- Няма гаранция, че две поредни итерации ще обходят елементите в еднакъв ред.

* Ползване без инициализация

- Държи се като празен при четене.
- Паникьосва се при писане.

        var m map[string]int
        delete(m, "oho") // Ok.

        _, ok := m["boho"] // Ok.
        fmt.Println(ok)

        fmt.Println(len(m)) // Ok.

        for k, v := range m { // Ok.
            fmt.Println(k, v)
        }
        
        m["footgun"] = 1 // panic: assignment to entry in nil map

* Ключове

- Трябва да са от "сравняем" тип

* Сравняване?

.link https://golang.org/ref/spec#Comparison_operators
- Накратко (и непълно): bool, numeric, string, channel, interface са сравними
- Масиви са сравними ако стойностите им са сравними и са равни когато всичките им стойности са равни
- Указатели са сравними и са равни когато сочат към една и съща променлива
- Структури са сравними, когато всичките им полета са сравними
- Има несравними неща, има и такива, които ще доведат до runtime panic ако ги сравнявате
- Прочетете поне веднъж спецификацията, където всичко е изброено пълно - кратка е

* Ключове

- Избягвайте интерфейсни ключове

	m := make(map[interface{}]string)
	m[42] = "42"
	
	x := []int{4, 2}
	m[x] = "HAHA!" // panic: runtime error: hash of unhashable type []int

* Конкурентен достъп

- За конкурентност ще говорим по - нататък, но за сега запомнете следните неща
- Ако се чете и пише едновременно в array, slice или map, поведенито е недефинирано
- a.k.a. не са thread-safe
- Често се случва паника

* Конкурентен достъп (2)

Но има [[https://golang.org/pkg/sync/#Map][sync.Map]] в стандартната библиотека, който позволява конкурентен достъп.

* Structs

- Добре познатите C структури
- Контейнер, който съдържа полета от други типове

    type Person struct {
        name string
        age uint
    }

    var chochko Person
    chochko.name = "Чочко"
    chochko.age = 27

Други начини за инициализиране:

    chochko := Person{name: "Чочко", age: 27}
    chochko := Person{"Чочко", 27}


* new()

- Алокира памет, която да използваме за дадения тип
- Връща указател към нулирана, но не инициализирана памет

    chochko := new(Person)
    chochko.name = "Чочко"
    chochko.age = 27

- chochko е *Person, но се използва по същия начин ('cause -> is so 80s)

* new() vs. make()

new само заделя и нулира памет, а make инициализира, т.е.:

.play code/data_structures/new_vs_make.go

- Демек `make` се ползва само върху `slice` и `map`

* Типове

* Собствени типове

- От всеки тип в езика можем да създаваме наши типове
- Не се различават по нищо от вградените

    type integer int
    type float float64
    type chars string

- Не особено полезно, на пръв поглед
- Но те могат и повече

* Нека разгледаме функцията Abs

    func Abs(i integer) integer {
        switch {
        case i < 0:
            return -i
        case i == 0:
            return 0
        default:
            return i
        }
    }

    var number integer = -42
    positiveInteger := Abs(number)

- Така се дефинира обикновена функция `Abs`, която се извиква като ѝ се подаде integer като аргумент
- Това не е "обектно-ориентираният" начин да се направи подобно нещо

* "Обектно-ориентираният" начин да се направи подобно нещо

    func (i integer) Abs() integer {
        switch {
        case i < 0:
            return -i
        case i == 0:
            return 0
        default:
            return i
        }
    }

    var number integer = -42
    number.Abs()


* Какво точно е метод?

- Методите се изпълняват върху конкретен тип
- Той се нарича receiver
- Методите могат да се дефинират *само* върху типове, дефинирани в същия пакет
- Като следствие от горното правило, методите имат достъп до private полетата в типа
- На практика, дефинират държанието на типа


* Що е то receiver-а?

- Няма фиксирана ключова дума за това.
- Има просто конвенция (първата/ите букви от името на типа)
- Той може да бъде по стойност, както и указател

По стойност

- Работи се върху копие на обекта
- Това може да е скъпа операция за големи обекти

Като указател

- Работи се върху копие на указателя към обект
- Всяка промяна в метода се отразява на оригиналния обект

Няма различен синтаксис за използването на двата вида receiver-и.


* Пример

.play code/types_and_interfaces/integer.go /^type/,/end/


* nil обекти

Извикването на методи работи дори с nil pointers към обекти:

.play code/types_and_interfaces/nil_objects.go /^type/,/end/

Внимавайте с тях :)


* struct

- Същите неща могат да се правят и върху композитни типове
- Полета и методи с малка буква са private
- Нека си дефинираме типове за триъгълник и правоъгълник

.code code/types_and_interfaces/shapes.go /start types/,/end types/


* Методи за тези типове

.code code/types_and_interfaces/shapes.go /start methods/,/end methods/


* "Завързани" методи

.play code/types_and_interfaces/bound_methods.go  /^type/,


* "Развързани" методи

.play code/types_and_interfaces/bound_methods2.go  /^type/,

